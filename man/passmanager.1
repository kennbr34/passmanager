.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.3.
.TH PASSMANAGER "1" "November 2018" "passmanager 1.24.1" "User Commands"
.SH NAME
passmanager \- manual page for passmanager 1.24.1
.SH SYNOPSIS
.PP
passmanager [\fB\-a\fR \fIentry name\fI\fR | \fB\-r\fR \fIentry name\fI\fR | \fB\-d\fR \fIentry name\fI\fR | \fB\-u\fR \fIentry name\fI\fR [-n \fInew name\fI\fR ] | \fB\-U\fR ] [\-p \fInew entry password\fI\fR] [\-l \fIrandom password length\fI\fR] [\-x \fIdatabase password\fI\fR] [\-c \fIcipher\fI\fR] [\-H \fIdigest\fI\fR] [ \fB\-P\fR ] \fB\-f\fR \fIdatabase file\fI\fR [ \fB\-C\fR ] [ \fB-s\fB\fR \fIseconds\fIs\fR ]

.PP
.SH OPTIONS SUMMARY
.PP
Options may have different implications depending on operating mode
.PP
\fB\-r\fR \fIentry name\fI\fR\ - Lookup \fIentry name\fI\fR in \fBRead\fR mode ('allpasses' will print all passes)
.PP
\fB\-a\fR \fIentry name\fI\fR\ - Add \fIentry name\fI\fR in \fBAdd\fR mode
.PP
\fB\-d\fR \fIentry name\fI\fR\ - Delete \fIentry name\fI\fR in \fBDelete\fR mode
.PP
\fB\-u\fR \fIentry name\fI\fR\ - Update \fIentry name\fI\fR in \fBUpdate entry\fR mode
.PP
\fB\-n\fR \fInew name\fI\fR\ - entry name up to 512 characters (can contain white space or special characters)
.PP
\fB\-U - \fBUpdate database\fB\fR mode
.PP
\fB\-p\fR \fInew entry password\fI\fR \- entry password up to 512 characters (don't call to be prompted instead) ('gen' will generate a random password, 'genalpha' will generate a random password with no symbols)
.PP
\fB\-l\fR \fIrandom password length\fI\fR \- makes 'gen' or 'genalpha' generate a password \fIrandom password length\fI\fR digits long (defaults to 16 without this option)
.PP
\fB\-x\fR \fIdatabase password\fI\fR \- To supply database password as command-line argument (not reccomended)
.PP
\fB\-c\fR \fIcipher\fI\fR \- Specify 'list' for a list of methods available to OpenSSL. Default: AES\-256\-CTR.
.PP
\fB\-H\fR \fIdigest\fI\fR \- Specify 'list' for a list of methods available to OpenSSL. Default: SHA512.
.PP
\fB\-P\fR - In \fIUpdate entry\fI\fR or \fIUpdate database\fI\fR  mode (\fB\-u\fR and \fB\-U\fR respectively) this option enables updating the \fIentry password\fI\fR or \fIdatabase password\fI\fR via prompt instead of as command line argument
.PP
\fB\-f\fR - \fIdatabase file\fI\fR ( must be specified )
.PP
\fB\-C\fR - end \fIentry password\fI\fR directly to clipboard. Clipboard is cleared 30 seconds afterward. (needs xclip)
.PP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30
.PP
\fB\-h\fR - Quick usage help
.PP

.SH DESCRIPTION

passmanager  is an ultra simple, but very secure password management program written in C and making use of OpenSSL's Libcrypto API libraries.  The
passwords can be written, read, updated or deleted from an encrypted database file.  


New passwords can be randomly generated when creating or updating account credentials. Passwords  can  be  matched by entry name, and printed/updated/deleted in bulk or individually. All password entries in the database can be updated at once with ease. If the user updated/deleted a password they didn't intend to, the program lists which entries were matched and edited, and provides an automatically produced backup file to restore from. The database password and encryption method can be changed at any time.


The program pays special attention to minimize the amount user passwords are displayed on screen or stored in memory, and allows them to be sent directly to the clipboard (via xclip). Allowing the passwords to be sent directly to the clipboard means adding, updating or retrieving a password can be done without it ever being visible on the screen. Even if a user must display an entry's password to verify it, only that pass can be printed, in order to prevent the entire database being displayed on screen.  Authenticated encryption protects the database against both data corruption and tampering.


Account credentials are stored with cascading encryption. First the YAXA stream cipher is used, and then the YAXA data is further encrypted using OpenSSL's EVP routines. Using OpenSSL's EVP functions also enables the use of any encryption and digest algorithm supported by  the EVP interface.  For example, encryption can be done with blowfish, and the KDF can use the whirlpool digest algorithm.  The default algorithm to use is 256-bit AES in CTR mode.


User input is stored in 512 byte buffers padded by cryptographically strong pseudorandom data: One for an entry's name, and the other for that entry's password.
This allows very large passwords, as well as long and flexible entry names, which can be comprised of service names and account names, and are best
delimited  with a colon. The program will print out each buffer delimited as a colon as well, in a list of "entry name : entry pass" format.  The
format of "entry name" is up to the user.

For example, here the user manually delimits the service and the account name

.RS 50
service : account : password
.sp 0
foobar : foo : passfoo
.sp 0
gmail : account@gmail.com : (*&*UJD83dh
.sp 0
.RE

.ad l
But any of these are also possible

.RS 50
just a user account : password
.sp 0
foo - bar : foobar : foobar
.sp 0
555 867 5309 : (*&*UJD83dh
.sp 0
.RE

.ad l
With this format and the modes provided, the user can easily and securely manage the contents of the database.

.SH MODES
.PP
.SS \fBAdd mode\fR
.PP
In \fBAdd\fB\fR mode the password database is initialized with the first entry, or a new entry is added to an existing password database. The user may specify a cipher and/or digest to use upon initialization of the database.
.PP
When adding a new entry, its password can be sent directly to clipboard.  This is especially useful for generating new passwords, where 'gen' can be given as the \fIentry password\fI\fR argument and the new randomly generated password will be sent to the clipboard.
.PP 
Applicable options
.RS
\fB\-p\fR \fInew entry password\fI\fR - 'gen' will generate a random password, 'genalpha' will generate a random password with no symbols
.HP
\fB\-l\fR \fIrandom password length\fI\fR \- makes 'gen' or 'genalpha' generate a password \fIrandom password length\fI\fR digits long (defaults to 16 without this option)
.HP
\fB\-x\fR \fIdatabase password\fI\fR
.HP
\fB\-c\fR \fIcipher\fI\fR \- Initializes a password database with cipher \fIcipher\fI\fR
.HP
\fB\-H\fR \fIdigest\fI\fR \- Initializes a password database with digest \fIdigest\fI\fR.
.HP
\fB\-C\fR send \fInew entry password\fI\fR to clipboard (useful if randomly generated)
.HP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30
.RE
.PP
.SS \fBRead mode\fR
.PP
In \fBRead\fB\fR mode the password database is searched for an entry with the name \fIentry name\fI\fR for partial or full matches so that \fIentry name\fI\fR of 'app' will find entry names 'apple' and 'appliances'. 
.PP
Entries can be specifically matched such as "gmail : account1" and "gmail : account2", or both with 'gmail'.
.PP
Searching for a specific entry pass can be useful to send the password directly to the clipboard using xclip.
.PP
To display the entire password database, enter 'allpasses' for the \fIentry name\fI\fR argument.
.PP
Applicable options
.RS
\fB\-x\fR \fIdatabase password\fI\fR
.HP
\fB\-C\fR send \fIentry name\fI\fR password directly to clipboard (useful to avoid displaying passwords on screen)
.HP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30
.RE
.PP
.SS \fBDelete mode\fR
.PP
In \fBDelete\fB\fR mode one or more password entries can be deleted. \fIentry name\fI\fR can be partially or fully matched as in \fBRead\fB\fR mode.
.PP
Applicable options
.RS
\fB\-x\fR \fIdatabase password\fI\fR
.RE
.PP
.SS \fBUpdate entry mode\fR
.PP
In \fBUpdate entry\fB\fR mode one or multiple entries are updated.  As in \fBRead\fB\fR and \fBAdd\fB\fR modes, the \fIentry name\fI\fR will be fully or partially matched.
.PP
Both the entry name and password can be updated. The new entry name can be supplied via command line only, but the new password can be received via prompt or as a command line argument ( not recommended ).
.PP
As in \fBAdd\fB\fR mode, entering 'gen' for the \fIentry password\fI\fR argument will generate a random password.  This is especially useful for updating old passwords.

Single new passwords can be sent directly to the clipboard with xclip as well.

All entries can be updated at once with new randomly generated passwords, if \fIentry name\fI\fR is equal to 'allpasses'
.PP
Applicable options
.RS
\fB\-P\fR
updates \fIentry name\fI\fR and \fIentry password\fI\fR, getting \fInew entry password\fI\fR via user input instead of command line (\fB\-p\fR)
.HP
\fB\-p\fR \fInew entry password\fI\fR \- update \fIentry name\fI\fR password to \fInew entry password\fI\fR
.HP
\fB\-l\fR \fIrandom password length\fI\fR \- makes 'gen' or 'genalpha' generate a password \fIrandom password length\fI\fR digits long (defaults to 16 without this option)
.HP
\fB\-n\fR \fInew name\fI\fR \- update \fIentry name\fI\fR  to \fInew name\fI\fR. Without this its assumed you're only changing the password of \fIentry name\fI\fR.
.HP
\fB\-x\fR \fIdatabase password\fI\fR
.HP
\fB\-C\fR send \fInew entry password\fI\fR directly to clipboard after updating \fIentry name\fI\fR
.HP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30
.RE
.PP
.SS \fBUpdate database mode\fR
.PP
In \fBUpdate databse\fB\fR mode the password and the underlying OpenSSL encryption of the database can be updated.
.PP
If option \fB-c\fB\fR or \fB-H\fB\fR given to update the encryption or digest algorithm ( respectively ) then \fB-P\fB\fR is needed to change the database password as well.
.PP
If only option \fB-U\fB\fR is present, then only the password id updated.
.PP
The new password can only be received via prompt, and cannot be given on the command line. However the current \fIdatabase password\fI\fR can still be received with the \fB-x\fB\fR option.
.PP
Applicable options
.RS
\fB\-P\fR
updates database password. Read via prompt. Cannot be supplied via commandline.
.HP
\fB\-x\fR \fIdatabase password\fI\fR (the current database password to decrypt/with)
.HP
\fB\-c\fR \fIcipher\fI\fR \- Update to \fIcipher\fI\fR
.HP
\fB\-H\fR \fIdigest\fI\fR \- Update to \fIdigest\fI\fR
.RE
.PP

.SH SECURITY

.SS Input Padding
Input buffers will accept any amount of whitespace or special characters up to 512 characters in length.  The buffers are padded with pseudo-random data from a Cryptographically Strong Pseudo Random Number Generator (CSPRNG). This was done with more consideration than simply providing ample memory for user input.

The extra space being padded with pseudo-random data also helps suppress natural-language frequencies, making frequency analysis of the plain-text less useful. This is because the padding always makes plaintext unique and pseudorandom despite any identical and/or predictable user input.  This also has the effect of lengthening the keystream generated, but without increasing determinism into it with more identical and/or predictable plain-text.

A different cipher-text will be generated for every password database file, even if it's encrypted with the same password, user input, and even the same salt. This is because plain-text will never be the same even with identical user input, due to the pseudo-random buffer padding.  Of course this only applies to the initialization of the database file; subsequent updates of the same file could have repeatable plain-text, so the use of salts and nonces is still necessary.

.SS Cascaded Encryption Security

In the classic Alice and Bob model, if Bob does not trust Alice's cipher, he can encrypt his message with his cipher, and then encrypt that cipher-text into a second cipher-text with Alice's cipher.  Alice can then decrypt it using her cipher, and then decrypt the second cipher-text using Bob's cipher.  In this way Bob does not have to trust Alice's cipher, and Alice is unaffected by vulnerabilities in Bob's cipher, and vise versa.  This is most widely known as cascaded encryption.

The primary purpose of the cascaded encryption in this program, however, is mainly to make the attack on its temporary files less practical than other side-channel attacks. Since the cryptographic strength of YAXA is so trivial, it cannot be said for sure that it actually adds any cryptographic strength to the encryption over a single algorithm, or just obscures the sensitive plain-text before sending to disk. It could be argued that the pseudorandom quality of the cipher-text produced by YAXA will even strengthen a second algorithm, but that is only to the extent that the second algorithm is dependent on its plain-text.  Some argue that in such a case, a cascaded cipher may be more susceptible to chosen plain-text attacks.

According to Bruce Schneier in "Applied Cryptography", as long as the first and second algorithm are both stream ciphers, then the combination of the two is at least as strong as the strongest algorithm.  Therefore if YAXA adds no significant cryptographic strength, then the combination of the two is still at least as strong as the second cipher used. If some vulnerability in YAXA was exploited, the cipher-text will only be as vulnerable as the second algorithm used by OpenSSL.  The default implementation being AES in CTR mode, that means regardless of YAXA's weaknesses, the password database's encryption will be at least as strong as AES.

.SS Enveloped Encryption Concept

This program conceptualizes the cryptographic concept of cascading and authenticated encryption as a figurative analogy involving envelopes. Not to be confused with how OpenSSL uses the concept, which is the name sake for the EVP functions.

The original plain-text message (the non-encrypted password database) is ran through HMAC-SHA512 to create a Message Authentication Code before being encrypted with the enveloped (first) algorithm, the YAXA stream cipher. The YAXA cipher-text message and the MAC are then placed together inside of an "envelope".  Therefore, the program uses two primary functions, \fIopenEnvelope()\fI\fR and \fIsealEnvelope()\fI\fR which contain the enveloping (second) algorithm's routines to "seal" the YAXA cipher-text message and MAC into an "envelope", or "open" an envelope containing them.

\fIsealEnvelope()\fI\fR is used to encrypt the YAXA ciphertext with the enveloping (second) algorithm after a database is created or modified.  The plain-text (user input and the padded buffers ) is ran through HMAC-SHA512 before encryption to create the MAC, then the MAC is concatenated to the YAXA ciphertext before being passed to \fIsealEnvelope()\fI\fR and encrypted with the enveloping (second) algorithm to form the final password database.  The encrypted password database file can be considered the "envelope" we're opening and sealing. \fIopenEnvelope()\fI\fR decrypts the cipher-text data created by OpenSSL (the second, or "enveloping" cipher), checks this with HMAC against the MAC, and if it matches, passes the YAXA data to the rest of the program functions for decryption and processing.

.SS Encryption and Authentication Composition

When using authentication codes, there are three distinct configurations in which one can encrypt and authenticate.  There is Authenticate-and-Encrypt, Authenticate-then-Encrypt, and Encrypt-then-Authenticate.  Must of the consensus on the subject would suggest that Encrypt-then-Authenticate is the most secure method due to theoretical and practical exploitation of the other two methods.

However, with this implementation of temporary files, the Encrypt-then-Authenticate approach did not prove to protect against simulated chosen-ciphertext attacks.  When spoofed ciphertext was inserted into the temporary files to simulate an attack, the Encrypt-then-Authenticate composition still allowed erroneous ciphertext bits to be inserted and decrypted.  As a more catastrophic result, the changes to the ciphertext were in some cases used to modify the YAXA data, and the resulting password database was corrupted.

Using the Authenticate-and-Encrypt form of composition, spoofing of the ciphertext in the temporary files was detected by the MAC upon decryption of the YAXA data, and then no further processing took place.  Therefore the temporary files can be injected with any spoofed data while open, but these changes will not be allowed to corrupt the password database unless the MAC was accurately spoofed, but measures to prevent that are described in the \fBTemporary Files vs Memory Buffers\fB\fR section below.

The primary flaw of the Authenticate-and-Encrypt format is that the MAC is written to the end of the file unencrypted, potentiating a leak of information about the plain-text if the one-way hash function leaks information.  However, this program uses a secure HMAC function provided by OpenSSL.  As well, there is the obvious fact that the YAXA data and MAC will then be encrypted with AES.

.SS Temporary Files vs Memory Buffers

The program uses temporary files to store and process data, rather than operate solely in memory. YAXA prevents that data from being sent to disk in plain-text. Data remanence issues of using temporary files to store the data for processing are obvious, and the Schneier 7-Pass method is used to erase sensitive data from files before exit.  The program cleans up these files, as well as buffers that were storing sensitive information, upon closing or receiving SIGINT or some other error. The temporary files are also protected by the authenticated encryption described above.

The temporary files are also given a random name that is of a random length, and with read/write permissions only for the file owner.  Despite this, it is still trivial to intercept data from these with elevated priveleges. To mitigate this, authenticated encryption helps protect against man-in-the-middle attacks attempting to spoof cipher-text data on its way from disk to memory. The attacker must be able to predict which random filename contains which data in order to spoof cipher-text and the checksum, and they would have to somehow time and automate such an attack.

Writing the program to function solely in memory would not necessarily make the program more secure, especially not in respect to any circumstance that would make storing the information to temporary files vulnerable (i.e. an attacker has root access to the machine the program runs on). At best it would only make the information harder to access without a filesystem abstraction; an attacker could write a simple shell script to intercept sensitive data from temp files, but would need to write something more sophisticated to access it from memory buffers. On the other hand, if the information in those temp files is encrypted, suddenly the level of sophistication needed to exploit them goes up.

With all that in mind, while operating solely in memory may seem much more secure superficially, the vulnerability of leaving the data in temporary files is only relevant in a situation where storage in memory is mutually vulnerable. Even then, YAXA obscures the plain-text, protects the temp files from tampering, and effectively makes an attack against the temporary files no simpler than an attack against program memory.

.SH YAXA

.SS YAXA Stream Cipher
YAXA (Yet Another XOR Algorithm) is so named because it is intended to form only the most rudimentary stream cipher akin to the "Simple XOR" approach, without any intent to be "unbreakable" or stronger than any other established algorithm.  The entire goal is to form the simplest encryption, but with the strongest security at that limited complexity level.  It is not intended to keep information secret for long periods of time, but rather to protect plain-text data written to temporary files.

.ad c
.SS YAXA Algorithm

.ad l
.RS 40
C₁ = E(P₁ ⊕ N₁ ⊕ KS₁ = f(K₁ ⊕ KC₁ = g(KC₁ + 1)))
.sp 0
C₁₀₂₄ = E(P₁₀₂₄ ⊕ N₀ ⊕ KS₁₀₂₄ = f(K₁₀₂₄ ⊕ KC₁₀₂₄ = g(KC₁₀₂₄ + 1)))
.sp 0
C₁₀₂₅ = E(P₁₀₂₅ ⊕ N₁ ⊕ KS₁₀₂₅ = f(K₁ ⊕ KC₁₀₂₅ = g(KC₁₀₂₅ + 1)))
.RE

.ad l
The YAXA key derivation function ( not diagrammed here) uses a 128-bit \fBInitialization Vector\fB\fR \fB(nonce)\fB\fR from a 64-byte salt used for OpenSSL, and uses PBKDF2 to generate a pseudo-random 8192 bit (or 1024 byte) key array \fB(K₁-₁₀₂₄)\fB\fR.  The iteration amount of PBKDF2 is based upon the length of the user supplied password of which the key \fB(K)\fB\fR is being derived, multiplied by a factor of 1000 (as recommended in RFC 2898), and added with a byte of the 128-bit salt,  so the iteration amount of PBKDF is \fBpassword-length *  1000 + nonce-byte\fB\fR.  The SHA512 hashing algorithm is then used to generate 16 different arrays of 64 CSPRNG bytes, concatenated into a buffer to form the 1024-byte key array. The salt is then used with PBKDF2 to create \fBN\fB\fR which is a 512-bit (64-byte) nonce XOR'd between the message byte and keystream byte. Note that \fBN\fB\fR and \fBK\fB\fR have an upper bound of 64 ( \fBNₙ\fB\fR will be N++ % 64) and 1024 respectively, but \fBKS\fB\fR will be generated to be as long as the message text.

The counter variable \fB(KC)\fB\fR is initialized to 1 and used in a keycounter generator \fB(g)\fB\fR, where it is merely incremented sequentially.  The decryption routine is the inverse of the encryption function \fB(E)\fB\fR.  The use of the \fBIV\fB\fR, counter variable \fB(KC)\fB\fR, counter function \fB(g)\fB\fR and key stream generator \fB(f)\fB\fR forms a very rudimentary \fBcounter-based stream cipher\fB\fR (Aumasson).

As the encryption function\fB(E)\fB\fR is incrementally applied to each byte in the message text \fB(P₁-₁₀₂₅)\fB\fR, the key counter variable \fB(KC)\fB\fR is updated in such fashion that it will not impart repeating patterns from the keystream \fB(KS₁-₁₀₂₅)\fB\fR into the ciphertext \fB(C₁-₁₀₂₅)\fB\fR like a running-key would, as happens when key byte\fB(K₁₀₂₄)\fB\fR becomes key byte \fB(K₁)\fB\fR again when the key array \fB(K₁-₁₀₂₄)\fB\fR bounds are reached; the 512-bit nonce similarly repeats after reaching its 64-byte bounds.

Finally, the keystream \fB(KS₁-₁₀₂₅)\fB\fR creates a non-periodic key to span the message length \fB(P₁-₁₀₂₅)\fB\fR which creates the 'one-time-pad'.  The program updates the salts used for IV/nonce generation upon every database update to avoid nonce reuse.

.SS YAXA Implementation Flaw

The key counter variable is declared as an integer, but returned from the YAXA encryption operation as a char.  This reduces
its overall size from 2^32 bytes, to just 255, which means the algorithm above would have induced a period in the
keystream at a very short interval of 1024 bytes.

.RS
\fBYAXA Encryption Function\fR
.sp 1
unsigned char yaxa(unsigned char messageByte, unsigned char keyByte, unsigned char nonceByte)
.sp 0
{
.sp 0
    return keyStreamGenByte++  ^ nonceByte ^ keyByte ^ messageByte;
.sp 0
}
.sp 1
'keyStreamGenByte ^ ...' represents the keystream generator function f()
.sp 0
the incrementation of keyStreamGenByte via keyStreamGenByte++ fulfills keycounter function g()
.sp 0
keyStreamGenByte will dually act as KC counter variable and generate KS byte
.sp 0
return line acts as function E()
.sp 1
.RE
.PP
If the iterator used to index yaxaKey array elements is only 1023 then the kystream repeats
every 1024 bytes.  The iterator must be allowed to index yaxaKey[1024]. An extra byte is allocated and derived for
this purpose to avoid undefined behavior of addressing yaxaKey[1024] if only allocated to 1024 bytes. This does not solve
the problem but it increases the period size to ~3.4 megabytes.  Since the password entries are padded in 1024 bytes of data,
this means that the password file can still contain 3331 password entires before the keystream becomes periodic.

.RS
\fBYAXA Buffer Iteration Loop\fR
.sp 1
for (i = 0; i < fileSize; i++)
.sp 0
{
.sp 1
        encryptedBuffer[i] = yaxa(decryptedBuffer[i], yaxaKey[ii], yaxaNonce[n]);
.sp 1            
		if(ii < 1024)
.sp 0
			ii++;
.sp 0				
		else if(ii == 1024)
.sp 0			
			ii=0;
.sp 0				
		if(n < 64)
.sp 0			
			n++;
.sp 0				
		else if(n == 64)
.sp 0			
			n=0;
.sp 0				
}
.sp 1
with 1025 byte key buffer and 65 byte nonce buffer the keystream still becomes periodic after 3411200 byte
.sp 0
if 1024 byte and 64 bytes were used instead, period would be at 1024 bytes
.sp 1
.RE

.HP
.SS Modified YAXA Algorithm

Subscript numbers except for KC's represet the array element being indexed
.sp 0
KC's subscript numbers represent the actual value of KC

At first byte of message
.sp 0
C₀ = E(P₀ ⊕ N₀ ⊕ KS₀ = f(K₀ ⊕ KC₀ = g(KC₁ + 1)))

At 64th byte of message
.sp 0
Note N's index rolls over to 0 after 64
.sp 0
C₆₄ = E(P₆₄ ⊕ N₆₄ ⊕ KS₆₄ = f(K₆₄ ⊕ KC₆₅ = g(KC₆₅ + 1)))
.sp 0
C₆₅ = E(P₆₅ ⊕ N₀ ⊕ KS₆₅ = f(K₆₅ ⊕ KC₆₆ = g(KC₆₆ + 1)))

At 1022th byte of message
.sp 0
KC will equal 255 and roll over to 0
.sp 0
C₁₀₂₂ = E(P₁₀₂₂ ⊕ N₄₇ ⊕ KS₁₀₂₂ = f(K₁₀₂₂ ⊕ KC₂₅₅ = g(KC₂₅₅ + 1)))
.sp 0
C₁₀₂₃ = E(P₁₀₂₃ ⊕ N₄₈ ⊕ KS₁₀₂₃ = f(K₁₀₂₃ ⊕ KC₀ = g(KC₀ + 1)))

At 1024th byte of message
.sp 0
Note K's index rolls over to 0 after 1024
.sp 0
C₁₀₂₄ = E(P₁₀₂₄ ⊕ N₄₉ ⊕ KS₁₀₂₄ = f(K₁₀₂₄ ⊕ KC₁ = g(KC₁ + 1)))
.sp 0
C₁₀₂₅ = E(P₁₀₂₅ ⊕ N₅₀ ⊕ KS₁₀₂₅ = f(K₀ ⊕ KC₁₀₂₅ = g(KC₁₀₂₅ + 1)))

.RE

.SS Security of YAXA

Even without the implementation flaw, YAXA is still almost certainly vulnerable to some other form of cryptanalysis with the simple relations in the YAXA keystream generator\fB(g)\fB\fR and function\fB(f)\fB\fR (only a ximple XOR of \fBKC\fB\fR against \fBK\fB\fR, and \fBKC\fB\fR merely being incremented ). A skilled cryptanalysis would likely find an exploitable vulnerability, even if the algorithm were programmed correctly. Standardized KDFs and CSPRNGs were used in hopes of avoiding determinism and bias, and tests were performed with dieharder and NIST STS to ensure the ciphter-text was indistingushable from pseudorandomness, but this relies on the pseudorandom input padding once the data set being encrypted goes beyond 3.4 MB. But that is the most that can be said for YAXA's strength.

However that's not to say that an cryptanalysis is inevitable, or even at all likely. An attack based on such cryptanalysis would be the least practical attack against this implementation. The exposure of YAXA data to be cryptanalyzed could only come about through conditions which imply a host of other conditions which would make things like keyloggers a more likely angle of attack. If an attacker had the resources and/or access required to get access to the YAXA data at all (breaking the cascaded encryption, forensic recovery, or man-in-the-middle type attacks), then they can find easier ways than cryptanalysis of YAXA to reveal the secrets (or gain access to whatever secrets those passwords are meant to protect).

While this cipher is not cryptographically strong, it is still secure enough for this implementation.  Its primary intent is to prevent the temporary files from being an easier target to retrieve sensitive information than obtaining it through system memory.

.SH OPENSSL

.SS OFB and CTR

\fBWhichever algorithm is used with OpenSSL, it should be used in OFB or CTR mode.\fB\fR  

The reason being is that these modes effectively turn block ciphers into stream ciphers, and the reason we would want that in this context is because using two stream ciphers in cascading encryption makes the resulting encryption at least as hard to break as the strongest algorithm.  Otherwise, if a mode like CBC is used, certain chosen plain-text attacks may be feasible to conduct against the 2nd algorithm in the cascade.  One such attack is known as a meet-in-the-middle attack, but as long as the cascaded algorithms are both stream ciphers, this attack is not feasible (Schneier).

One caveat to using these modes is that the OpenSSL routines don't check for decryption error with them, and so entering an incorrect password will not prompt the user with a "Wrong key" message like other modes would.  Instead, OpenSSL will decrypt the ciphertext with the incorrect key, and then the MAC will fail because the resulting YAXA cipher-text will not match what was generated by HMAC.

.SS OpenSSL Ciphers

The encryption algorithm used by OpenSSL can be chosen between the ciphers provided by the high-level functions in the \fIevp(3)\fI\fR library. By default the program uses 256-bit AES in CTR mode, using the \fIEVP_BytesToKey(3)\fI\fR function to derive the key (see \fIEVP_BytesToKey(3)\fI\fR for details), and the SHA512 digest algorithm therein. 

The EVP library provides access to many different blocking modes as well as different cipher algorithms. The choice of which of these respective algorithms to use was made available simply because it was possible to with ease.  For this program's use, AES-256 in CTR mode with SHA512 digests is the strongest configuration available using NIST standards.  Otherwise, blowfish (in OFB) and whirlpool may be an alternative open-source configuration; the rationale to use these could be that both algorithms are slow, so it would make bruteforcing against them slower, or not trusting national encryption standards, etc.  Whatever your rationale for preferring one algorithm over the other, the program will allow it.

There are also some exotic digest options such as "RSA encrypted SHA512" which might provide extra security over SHA512 alone.  However, OpenSSL's documentation is not clear on what this entails or how it should be implemented, so it is probably safer to use the more vanilla offerings.

There are a number of cipher options listed that do not work, for reasons that were not analyzed. Priority wasn't given to making these options function.

.RS
aes-128-ccm
.sp 0
aes-128-gcm
.sp 0

aes-192-ccm
.sp 0
aes-192-gcm

aes-256-ccm
.sp 0
aes-256-gcm

des-ede3-cfb1

id-aes128-wrap
.sp 0
id-aes192-wrap
.sp 0
id-aes256-wrap
.RE

.SS Key Derivation

The key derivation is done by \fIEVP_BytesToKey(3)\fI\fR which is described in detail in \fIEVP_BytesToKey(3)\fI\fR and in brief in \fIevp(3)\fI\fR:

.RS
The EVP_BytesToKey function provides some limited support for password based encryption. Careful selection of the parameters will provide a PKCS#5 PBKDF1 compatible implementation. However, new applications should not typically use this (preferring, for example, PBKDF2 from PCKS#5).
.RE

However since the default configuration uses SHA512 instead of MD5, and the digest can be user specified, this means it does not necessarily meet the PBKDF1 standards.  The decision not to use PBKDF2 was made because the EVP library KDF automatically generates appropriate keyring material for the specified ciphers.  Some use IVs and some don't, and some require different key lengths.  The \fIEVP_BytesToKey(3)\fI\fR function handles all that automatically.  Meanwhile it could be argued that SHA512 is much more impervious to collisions than MD5 so there's no reason to believe this implementation is less secure than PBKDF1 due to the use of a stronger digest algorithm.

.SS CSPRNG

The EVP library also provides access to OpenSSL's CSPRNG as described in \fIRAND(3)\fI\fR.  The \fIRAND_bytes(3)\fI\fR function is what fills the buffers with pseudorandomness, generates random passwords, and generates the salt which generates YAXA's nonce as well.

.SH EXAMPLES

Initialize a new password database and save it to the file passwords.  Also randomly generate a password of 32 characters for the new entry, and send that new password to the clipboard.

.RS
passmanager -a "gmail : myemail@gmail.com" -p gen -l 32 -f ./passwords -C
.RE

Change the encryption and/or digest used for the password database

.RS
passmanager -U -c blowfish -H whirlpool -f ./passwords
.RE

Print a list of available ciphers

.RS
passmanager -c list
.RE

Print a list of available digests

.RS
passmanager -H list
.RE

Can also change password for the database (Will be prompted for input)

.RS
passmanager -U -f ./passwords
.RE

Or you could do both in one command

.RS
passmanager -U -c aes-256-cbc -H sha512 -P -f ./passwords
.RE

Update the previously added entry name from "gmail : myemail@gmail.com" to "gmail : myemail1@gmail.com" (Note how we're partially matching "gmail", and the need for quotations around the new entry name since it contains whitespace)

.RS
passmanager -u gmail -n "gmail : myemail1@gmail.com" -f ./passwords
.RE

Add a second gmail account but with the entry password "password"

.RS
passmanager -a "gmail : myemail2@gmail.com" -p password -f ./passwords
.RE

If you are following these examples sequentially, this is how you would print out your password database, and what it would look like on screen.

.RS 
passmanager -r allpasses -f ./passwords
.RE

.RS 40
gmail : myemail1@gmail.com : Us3[Ag1<lRw9%Vj5>La0{Nh4|Kr8$Te7
.sp 0
gmail : myemail2@gmail.com : password
.RE

.sp 1
To update the password for myemail2@gmail.com with a randomly generated 16 character (default) password, and send the newly created password to clipboard

.RS
passmanager -u "gmail : myemail2" -p gen -f ./passwords -C
.RE

To update the passsword but prompt the user for password

.RS
passmanager -u "gmail : myemail2" -P -f ./passwords
.RE

Read the new password for myemail2@gmail.com and send it directly to the clipboard

.RS
passmanager -r "gmail : myemail2" -C -f ./passwords
.RE

Or to just print both gmail passwords on screen ( but no other entry passwords )

.RS
passmanager -r gmail -f ./passwords
.RE

To delete both of the gmail accounts. (Note no need for quotation marks since we can partially match both entry names before the whitespace portions)

.RS
passmanager -d gmail -f ./passwords
.RE

To print all passwords in database, and supply the database password as a command-line argument (Perhaps to fill in from some other location besides user input)

.RS
passmanager -r allpasses -f ./passwords -x password
.RE

To update all passwords in database with a randomly generated passwords

.RS
passmanager -u allpasses -p gen -f ./passwords
.RE

.SH BUGS



.SH REFERENCES

The author consulted several reference sources in order to design and describe the cryptographic function of this program.

\fI"Applied Cryptography,"\fI\fR Bruce Schneier
.sp 0
\fI"Serious Cryptography,"\fI\fR Jean-Philippe Aumasson
.sp 0
\fI"Cryptography Engineering,"\fI\fR Ferguson, Schneier, Kohno
.sp 0
\fI"Cryptography Theory and Practice 4th Ed,"\fI\fR Stinson, Paterson
.sp 0
\fI"Handbook of Applied Cryptography,"\fI\fR Alfred J. Menezes

.SH "SEE ALSO"
openssl(1), xclip(1), crypto(3), evp(3), EVP_BytesToKey(3), EVP_EncryptInit(3), PKCS5_PBKDF2_HMAC(3), RAND(3), RAND_bytes(3)


