.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.3.
.TH PASSMANAGER "1" "January 2019" "passmanager 3.2.8" "User Commands"
.SH NAME
passmanager \- manual page for passmanager 3.2.8
.SH SYNOPSIS
.PP
passmanager \fB\-a\fR \fIentry name\fI\fR | \fB\-r\fR \fIentry name\fI\fR | \fB\-d\fR \fIentry name\fI\fR | \fB\-u\fR \fIentry name\fI\fR | \fB\-U\fR [-n \fInew name\fI\fR ] [\-p \fInew entry password\fI\fR] [\-l \fIrandom password length\fI\fR] [\-c \fIcipher\fI\fR] [\-H \fIdigest\fI\fR] [\-i \fIiterations\fI\fR ] [ \-P ] [ \-C ] [ \-s \fIseconds\fI\fR ] [\-x \fIdatabase password\fI\fR] \fB\-f\fR \fIdatabase file\fI\fR

.PP
.SH OPTIONS SUMMARY
.PP
Options may have different implications depending on operating mode
.PP
\fB\-a\fR \fIentry name\fI\fR\ - Add \fIentry name\fI\fR in \fBAdd\fR mode
.PP
\fB\-r\fR \fIentry name\fI\fR\ - Lookup \fIentry name\fI\fR in \fBRead\fR mode ('allpasses' will print all passes)
.PP
\fB\-d\fR \fIentry name\fI\fR\ - Delete \fIentry name\fI\fR in \fBDelete\fR mode
.PP
\fB\-u\fR \fIentry name\fI\fR\ - Update \fIentry name\fI\fR in \fBUpdate entry\fR mode
.PP
\fB\-U - \fBUpdate database\fB\fR mode
.PP
\fB\-n\fR \fInew name\fI\fR\ - entry name up to 511 characters (can contain white space or special characters)
.PP
\fB\-p\fR \fInew entry password\fI\fR \- entry password up to 511 characters (don't call to be prompted instead) ('gen' will generate a random password, 'genalpha' will generate a random password with no symbols)
.PP
\fB\-l\fR \fIrandom password length\fI\fR \- makes 'gen' or 'genalpha' generate a password \fIrandom password length\fI\fR digits long (defaults to 16 without this option)
.PP
\fB\-c\fR \fIcipher\fI\fR \- Specify 'list' for a list of methods available to OpenSSL. Default: aes-256-ctr.
.PP
\fB\-H\fR \fIdigest\fI\fR \- Specify 'list' for a list of methods available to OpenSSL. Default: sha512.
.PP
\fB\-i\fR \fIiterations\fI\fR \- Specify amount of PBKDF2 to be \fIiterations\fI\fR. Default: 1000000
.PP
\fB\-P\fR - In \fIUpdate entry\fI\fR or \fIUpdate database\fI\fR  mode (\fB\-u\fR and \fB\-U\fR respectively) this option enables updating the \fIentry password\fI\fR or \fIdatabase password\fI\fR via prompt instead of as command line argument
.PP
\fB\-C\fR - send \fIentry password\fI\fR directly to clipboard. Clipboard is cleared automatically after pasting, or in 30 seconds if using xclip for xclipboard functions.
.PP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30.
.PP
\fB\-x\fR \fIdatabase password\fI\fR \- To supply database password as command-line argument (not reccomended)
.PP
\fB\-I\fR \- Print database information
.PP
\fB\-f\fR - \fIdatabase file\fI\fR ( must be specified )
.PP
\fB\-h\fR - Quick usage help
.PP

.SH DESCRIPTION

passmanager  is an ultra simple, but very secure password management program written in C and making use of OpenSSL's Libcrypto API libraries.  The
passwords can be written, read, updated or deleted from an encrypted database file.  


New passwords can be randomly generated when creating or updating account credentials. Passwords  can  be  matched by entry name, and printed/updated/deleted in bulk or individually. All password entries in the database can be updated at once with ease. If the user updated/deleted a password they didn't intend to, the program lists which entries were matched and edited, and provides an automatically produced backup file to restore from. The database password and encryption method can be changed at any time.


The program pays special attention to minimize the amount user passwords are displayed on screen or stored in memory, and allows them to be sent directly to the clipboard (via integrated xclip code (default), or xclip binary depending on compilation options), with the password being cleared from the clipboard afterward. Allowing the passwords to be sent directly to the clipboard means adding, updating or retrieving a password can be done without it ever being visible on the screen. Even if a user must display an entry's password to verify it, only that pass can be printed, in order to prevent the entire database being displayed on screen.  Authenticated encryption with HMAC protects the database against both data corruption and tampering.


Account credentials are encrypted with 256-bit AES in CTR mode with HMAC-SHA512 for authentication. Using OpenSSL's EVP functions also enables the use of any encryption and digest algorithms ( for key derivation using PBKDF2 ) supported by  the EVP interface.


User input is stored in 512 byte buffers padded by cryptographically strong pseudorandom data: One for an entry's name, and the other for that entry's password.
This allows very large passwords, as well as long and flexible entry names, which can be comprised of service names and account names, and are best
delimited  with a colon. The program will print out each buffer delimited as a colon as well, in a list of "entry name : entry pass" format.  The
format of "entry name" is up to the user.

For example, here the user manually delimits the service and the account name

.RS 50
service : account : password
.sp 0
foobar : foo : passfoo
.sp 0
gmail : account@gmail.com : (*&*UJD83dh
.sp 0
.RE

.ad l
But any of these are also possible

.RS 50
just a user account : password
.sp 0
foo - bar : foobar : foobar
.sp 0
555 867 5309 : (*&*UJD83dh
.sp 0
.RE

.ad l
With this format and the modes provided, the user can easily and securely manage the contents of the database.

.SH MODES
.PP
.SS \fBAdd mode\fR
.PP
In \fBAdd\fB\fR mode the password database is initialized with the first entry, or a new entry is added to an existing password database. The user may specify a cipher and/or digest to use upon initialization of the database.
.PP
When adding a new entry, its password can be sent directly to clipboard.  This is especially useful for generating new passwords, where 'gen' can be given as the \fIentry password\fI\fR argument and the new randomly generated password will be sent to the clipboard.
.PP 
Applicable options
.RS
\fB\-p\fR \fInew entry password\fI\fR - 'gen' will generate a random password, 'genalpha' will generate a random password with no symbols
.HP
\fB\-l\fR \fIrandom password length\fI\fR \- makes 'gen' or 'genalpha' generate a password \fIrandom password length\fI\fR digits long (defaults to 16 without this option)
.HP
\fB\-x\fR \fIdatabase password\fI\fR
.HP
\fB\-c\fR \fIcipher\fI\fR \- Initializes a password database with EVP cipher algorithm 'cipher'
.HP
\fB\-H\fR \fIdigest\fI\fR \- Derives keys for ciphers with EVP digest algorithm 'digest'
.HP
\fB\-C\fR send \fInew entry password\fI\fR to clipboard (useful if randomly generated)
.HP
\fB\-i\fR \fIiterations\fI\fR - Specify PBKDF2 iteration amount as \fIiterations\fI\fR.
.HP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30
.RE
.PP
.SS \fBRead mode\fR
.PP
In \fBRead\fB\fR mode the password database is searched for an entry with the name \fIentry name\fI\fR for partial or full matches so that \fIentry name\fI\fR of 'app' will find entry names 'apple' and 'appliances'. 
.PP
Entries can be specifically matched such as "gmail : account1" and "gmail : account2", or both with 'gmail'.
.PP
Searching for a specific entry pass can be useful to send the password directly to the clipboard using xclip. Note that if multiple entries match your search string, only the first matched entry will be sent to the clipboard.
.PP
To display the entire password database, enter 'allpasses' for the \fIentry name\fI\fR argument.
.PP
Applicable options
.RS
\fB\-x\fR \fIdatabase password\fI\fR
.HP
\fB\-C\fR send \fIentry name\fI\fR password directly to clipboard (useful to avoid displaying passwords on screen)
.HP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30
.RE
.PP
.SS \fBDelete mode\fR
.PP
In \fBDelete\fB\fR mode one or more password entries can be deleted. \fIentry name\fI\fR can be partially or fully matched as in \fBRead\fB\fR mode.
.PP
Applicable options
.RS
\fB\-x\fR \fIdatabase password\fI\fR
.RE
.PP
.SS \fBUpdate entry mode\fR
.PP
In \fBUpdate entry\fB\fR mode one or multiple entries are updated.  As in \fBRead\fB\fR and \fBAdd\fB\fR modes, the \fIentry name\fI\fR will be fully or partially matched.
.PP
Both the entry name and password can be updated. The new entry name can be supplied via command line only, but the new password can be received via prompt or as a command line argument ( not recommended ).
.PP
As in \fBAdd\fB\fR mode, entering 'gen' for the \fIentry password\fI\fR argument will generate a random password.  This is especially useful for updating old passwords.

Single new passwords can be sent directly to the clipboard with xclip as well. Note that if multiple entries match your search string, only the first matched entry will be updated and sent to the clipboard.

All entries can be updated at once with new randomly generated passwords, if \fIentry name\fI\fR is equal to 'allpasses'
.PP
Applicable options
.RS
\fB\-P\fR
updates \fIentry name\fI\fR and \fIentry password\fI\fR, getting \fInew entry password\fI\fR via user input instead of command line (\fB\-p\fR)
.HP
\fB\-p\fR \fInew entry password\fI\fR \- update \fIentry name\fI\fR password to \fInew entry password\fI\fR
.HP
\fB\-l\fR \fIrandom password length\fI\fR \- makes 'gen' or 'genalpha' generate a password \fIrandom password length\fI\fR digits long (defaults to 16 without this option)
.HP
\fB\-n\fR \fInew name\fI\fR \- update \fIentry name\fI\fR  to \fInew name\fI\fR. Without this itâ€™s assumed you're only changing the password of \fIentry name\fI\fR.
.HP
\fB\-x\fR \fIdatabase password\fI\fR
.HP
\fB\-C\fR send \fInew entry password\fI\fR directly to clipboard after updating \fIentry name\fI\fR
.HP
\fB-s\fB\fR \fIseconds\fI\fR - clear clipboard \fIseconds\fI\fR after instead of default 30
.RE
.PP
.SS \fBUpdate database mode\fR
.PP
In \fBUpdate database\fB\fR mode the password and the underlying OpenSSL encryption of the database can be updated.
.PP
If option \fB-c\fB\fR or \fB-H\fB\fR given to update the encryption or digest algorithm ( respectively ) then \fB-P\fB\fR is needed to change the database password as well.
.PP
If only option \fB-U\fB\fR is present, then only the password is updated.
.PP
The new password can only be received via prompt, and cannot be given on the command line. However the current \fIdatabase password\fI\fR can still be received with the \fB-x\fB\fR option.
.PP
Applicable options
.RS
\fB\-P\fR
updates database password. Read via prompt. Cannot be supplied via commandline.
.HP
\fB\-x\fR \fIdatabase password\fI\fR (the current database password to decrypt/with)
.HP
\fB\-c\fR \fIcipher\fI\fR \- Updates algorithms
.HP
\fB\-H\fR \fIdigest\fI\fR \- Update digests used
.HP
\fB\-i\fR \fIiterations\fI\fR - Update iteration amount used by PBKDF2 to \fIiterations\fI\fR
.RE
.PP

.SH OPENSSL NOTES

.SS OpenSSL Ciphers and Digests

The encryption algorithm used by OpenSSL can be chosen between the ciphers provided by the high-level functions in the \fIevp(3)\fI\fR library. By default the program uses 256-bit AES in CTR mode, using the \fIPKCS5_PBKDF2_HMAC(3)\fI\fR function to derive keys (see \fIPKCS5_PBKDF2_HMAC(3)\fI\fR for details), and the SHA512 digest algorithm. Authenticated ciphers using GCM or CCM are not supported as the program uses HMAC for authentication. The ability to choose cipher algorithms is primarily added incase different versions of OpenSSL are installed across different machine, thus making different ciphers available.  For example, ChaCha20 may not be available on one machine while it is on the other.

.SS CSPRNG

The EVP library also provides access to OpenSSL's CSPRNG as described in \fIRAND(3)\fI\fR.  The \fIRAND_bytes(3)\fI\fR function is what fills the buffers with pseudorandomness, generates random passwords, and generates the salt for PBKDF2.

.SH SECURITY AND DESIGN NOTES

.SS Input Padding

Input buffers will accept any amount of whitespace or special characters up to 511 characters in length.  The buffers are padded with pseudo-random data from a Cryptographically Strong Pseudo Random Number Generator (CSPRNG). This was done with more consideration than simply providing ample memory for user input. The extra space being padded with pseudo-random data also helps suppress natural-language frequencies, making frequency analysis of the cipher-text less useful.

.SS Database Creation and Modification

The cipher-text and IV of the EVP algorithm chosen is ran through HMAC-SHA512 to create a Message Authentication Code in Encrypt-then-MAC composition. The header, cipher-text and the MAC are then placed together inside of a database file, which is then also authenticated with a separate MAC.  Therefore, the reading and writing of the database file is driven by two primary functions, \fIopenDatabase()\fI\fR and \fIwriteDatabase()\fI\fR which contain the routines to write the cipher-text message and MACs into a database, or to read a database containing them. Every database file created has its own unique 256-bit salt to be used by PBKDF2 and is prepended to the header to ensure no keys ( for both encryption and HMAC) or IVs are reused across mulitiple database files. This salt is also updated any time a modification to the database is made.

\fIwriteDatabase()\fI\fR is used to write the cipher-text of the user input to a database file also containing a salt, cipher and digest names, and PBKDF2 iteration amount as a header, the cipher text, and finally the MACs.  The cipher-text of the EVP algorithm is ran through HMAC-SHA512 to create the MAC, then the cipher-text is sent to \fIwriteDatabase()\fI\fR, prepended with the header, and finally written to file as the database with both a MAC of the cipher-text itself, and the MAC of the header plus the cipher-text appended.  The resulting file can be considered the database we're reading and writing, which contains the encrypted password database inside, sandwiched betwen the header and the MACs. 

\fIopenDatabase()\fI\fR strips the header, storing the salt, cipher and digest names, PBKDF2 iteration amount, and MACs to be used, and then passes cipher-text on to a buffer for decryption and processing.  Only if the MACs generated match the MACs attached to the cipher-text does the program do any decryption. The separate modes process information in from a buffer to make any modications, and once complete, the buffer with the modifications made is passed back to \fIwriteDatabase()\fi\fR to overwrite the pervious databse with the modifications made.

.SS Authenicated Encryption and Associated Data

Two MACs are generated and appended to the database file for authentication of both the ciper-text held in temporary buffers, as well as the database file itself.  The cipher-text MAC is generated on the cipher-text alone and verified within each processing mode so that alterations to the cipher-text through the temporary buffers will be detected and thwart any type of man-in-the-middle attack. The database file as a whole is also authenticated so that the associated data (salt, cipher name, digest name and key derivation configuration) can also be authenticated and detected upon opening the database before other processing modes are used.

.SS Memory Sanitation

\fIOPENSSL_cleanse()\fi\fR is used to ensure sanitation calls aren't optimized away by the compiler.

.SS Memory Locking, Core-Dump and Process-Trace Prevention

The program will attempt to "lock" all memory, which will prevent it from accidentally being swapped out to disk.  It also prevents process tracing, and core dump upon crash.  In order to do this, the program needs root priveleges, but drops them after these settings have been made. The executable is installed with the SETUID and SETGID bits and with root as the owner, so the user need not execute it as root or with sudo.

.SS Clipboard Functionality

Automatically sending passwords to the clipboard is handled by X library calls, or by piping out to a xlip binary installed on the system. The former should be preferred for best security and functionality, but the latter is more portable, and both options can be choosen at compile time with autoconf's configuration script.

The internal X library calls offer better security because passwords are cleared from memory and from the clipboard selection at a specified amount of seconds after pasting (defaults to 30).  The countdown does not begin until a password is pasted, and if a password is pasted again, the countdown resets again to faciliatate multiple pastings.

On the contrary, with piping to an external xclip binary, passwords are not cleared from memory, and the countdown to clear the password is began regardless of whether the password was pasted or not, and does not reset. However, piping to an xclip binary is far more portable as a user can control where the password is piped to. The program will simply pipe to any binary or alias that can be invoked by 'xclip'.  If for example, a user is on a system using Wayland instead, 'xclip' could be aliased to 'xclip -selection c' or be a symbolic link pointing to something like 'wl-clipboard'.

.SH EXAMPLES

Initialize a new password database using blowfish encryption, whirlpool for key digest, and 750000 PBKDF2 iterations, and save it to the file 'passwords'.  Also randomly generate a password of 32 characters for the new entry, and send that new password to the clipboard, clearing it from  memory in 5 seconds

.RS
passmanager -a "gmail : myemail@gmail.com" -p gen -c bf-ofb -H whirlpool -i 750000 -l 32 -C -s 5 -f ./passwords
.RE

Print a list of available ciphers

.RS
passmanager -c list
.RE

Print a list of available digests

.RS
passmanager -H list
.RE

Can also change password for the database (Will be prompted for input)

.RS
passmanager -U -f ./passwords
.RE

Or you could do both change the password, the encryption and digest algorithms, and PBKDF2 iteration amount in one command

.RS
passmanager -U -c aes-256-ctr -H whirlpool -i 1000000-P -f ./passwords
.RE

Update the previously added entry name from "gmail : myemail@gmail.com" to "gmail : myemail1@gmail.com" (Note how we're partially matching "gmail", and the need for quotations around the new entry name since it contains whitespace)

.RS
passmanager -u gmail -n "gmail : myemail1@gmail.com" -f ./passwords
.RE

Add a second gmail account but with the entry password "password"

.RS
passmanager -a "gmail : myemail2@gmail.com" -p password -f ./passwords
.RE

If you are following these examples sequentially, this is how you would print out your password database, and what it would look like on screen.

.RS 
passmanager -r allpasses -f ./passwords
.RE

.RS 40
gmail : myemail1@gmail.com : Us3[Ag1<lRw9%Vj5>La0{Nh4|Kr8$Te7
.sp 0
gmail : myemail2@gmail.com : password
.RE

.sp 1
To update the password for myemail2@gmail.com with a randomly generated 16 character (default) password, and send the newly created password to clipboard

.RS
passmanager -u "gmail : myemail2" -p gen -C -f ./passwords
.RE

To update the passsword but prompt the user for password

.RS
passmanager -u "gmail : myemail2" -P -f ./passwords
.RE

Read the new password for myemail2@gmail.com and send it directly to the clipboard

.RS
passmanager -r "gmail : myemail2" -C -f ./passwords
.RE

Or to just print both gmail passwords on screen ( but no other entry passwords )

.RS
passmanager -r gmail -f ./passwords
.RE

To delete both of the gmail accounts. (Note no need for quotation marks since we can partially match both entry names before the whitespace portions)

.RS
passmanager -d gmail -f ./passwords
.RE

To print all passwords in database, and supply the database password as a command-line argument (Perhaps to fill in from some other location besides user input)

.RS
passmanager -r allpasses -x password -f ./passwords
.RE

To update all passwords in database with a randomly generated passwords

.RS
passmanager -u allpasses -p gen -f ./passwords
.RE

.SH BUGS

Dead-store elimination means that some of the sensitive material in memory buffers may not be able to be cleared.  The makefile provided disables optimization, and OPENSSL_cleanse is used if a user wishes to implement optimzation anyway.  Despite that, dead-store elimination has been found to be present in OpenSSL <=1.0.1q itself as well.

.SH "SEE ALSO"
openssl(1), xclip(1), crypto(3), evp(3), EVP_EncryptInit(3), PKCS5_PBKDF2_HMAC(3), RAND(3), RAND_bytes(3)



